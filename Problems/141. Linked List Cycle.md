# Python
## Floyd's Tortoise and Hair Algorithm
Here's how Floyd's Tortoise and Hare Algorithm works:

1. **Initialization:** Start with two pointers, often called the "tortoise" and the "hare," both initially pointing to the beginning of the sequence.  
2. **Movement of Pointers:** The tortoise moves one step at a time (tortoise = tortoise.next).The hare moves two steps at a time (hare = hare.next.next).  
3. **Cycle Detection:** If the sequence contains a cycle, eventually, the hare will meet the tortoise within the cycle. This happens because the faster-moving hare will loop around and eventually catch up to the slower-moving tortoise. If there's no cycle, the hare will reach the end of the sequence (i.e., hare.next or hare.next.next will become null).  
4. **Cycle Identification:** Once the hare catches up with the tortoise, it means there's a cycle in the sequence. After detecting the collision, if we reset one of the pointers (either tortoise or hare) to the start of the sequence and move both pointers at the same speed (both move one step at a time), they will eventually meet at the start of the cycle.  
5. **Applications:** This algorithm is commonly used in linked list problems to detect cycles in the list. It's also useful in various algorithms and problems related to cycle detection in graphs and sequences.  

```
class Solution(object):
  def hasCycle(self, head):
      slow, fast = head, head
      while fast and fast.next:
        slow.next
        fast.next.next
        if slow ==  fast:
          return True

      return False
```
- 什么是head? 为什么令slow和fast = head?????  
1. The variable head represents the starting point or the head node of a singly-linked list. In the context of a linked list, the ListNode class defines nodes, and each node contains a value (val) and a pointer to the next node (next). The head is typically the entry point or the first node of the linked list.  
2. The line slow, fast = head, head initializes two pointers (slow and fast) to the starting node of the linked list (head). This is part of the Floyd's Tortoise and Hare Algorithm for cycle detection in a linked list.  
- 为什么slow和fast+1是使用.next，却没有赋值给slow和fast？  
**Pointer Movement Issue:** slow.next and fast.next.next don't actually update the slow and fast pointers to their next nodes. They only access the next attribute of the nodes but do not progress the pointers forward in the linked list.  
To move the pointers to the next nodes, you should assign slow = slow.next and fast = fast.next.next.   
- 返回布尔值就是输出布尔值吗？？？？？
  Yes  
